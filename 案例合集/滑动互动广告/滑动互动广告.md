仿照在刷科目一时的软件广告,觉得很有意思,故而仿之;
滑动到一定范围后,全部清除,并且弹窗(这里gif没有录制到)
![[PixPin_2024-07-27_23-39-15.gif]]
要实现这个效果,初步分析为是`stack`叠上`CustomPaint`和图片
但是实际实现起来并不是和想象中的一样
![[Pasted image 20240731004358.png]]
现在问题则在,
- 灰色半透明是谁给的?
- 绘制应该绘制什么?
- 怎么判断绘制到一定量后会实现跳转或者实现取消绘画进度
下面来解决问题
## 目前的思路
至少截止到2024.7.31日时还没想出第二种怎么解决绘制的问题
第一种的思路是绘制图片来遮挡半透明阴影
## 第一种解决方法
==思路==
用`stack`来层叠多个组件实现
最底层的组件则是图片本身,
其次是半透明的灰色遮罩(这个也可以用过滤器来实现,但是这里用不到)
最顶层则是绘制组件
==绘制==
因为是绘制图片,所以绘制方法采用`drawImageRect`.
```
canvas.drawImageRect(image!, srcRect, dstRect, paint);
//image是图片源
//srcRect是来自图片的区域
//dstRect是实际画的位置
//paint是画笔
```
于是有了下面这个例子
暂且忽视`point.toOffset()`在这里的作用只是一个坐标点,比如`Offset(10,10)`
```
final srcRect = Rect.fromLTWH(  
  point.toOffset().dx * 2,  
  point.toOffset().dy * 2,  
  20,  
  20,  
);  
final dstRect = Rect.fromLTWH(  
  point.toOffset().dx,  
  point.toOffset().dy,  
  10,  
  10,  
);   
canvas.drawImageRect(image!, srcRect, dstRect, paint);
```
用这个方法,就可以画出2:1的图片
![[Pasted image 20240731133827.png]]
==这里有个小技巧==
srcRect与dstRect的比例就是绘制出来的比例,或者也可以看成缩放,2:1相当于缩放了一倍
==现在图片绘制也实现了,接下来是一点点绘制出来==
这里采用`GestureDetector`来配合绘制,获取手势位移,来绘制图片
....这里暂时省略....
![[Pasted image 20240731134531.png]]
是不是已经初步实现了
==现在的问题则是第三个==
怎么判断绘制了多少范围
### 想法一
去除重复的点,每个点的矩形大小是固定的,所以所有点的面积总和超过一定量时,认为是绘制完成,
缺点:目前的绘制是一个线的合集,线里有点的合集,这样要计算所有面积则需要
(线里的所有点*固定面积)*所有线
看着没什么问题,可是不同线的点怎么确认是否重复
位置重复的点不计算进面积?
禁止位置重复的点?
位置重复时删除之前线段重复的点?
第二,三的计算太大了吧???
那就采用==位置重复的点不计算进面积==
### 位置重复的点不计算进面积
